[{"title":"2016年总结以及17年展望","url":"http://yoursite.com/2017/01/20/2016年总结以及17年展望/","content":"<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>时光荏苒，16年过得尤其快，回顾这一年发生的事情有喜有悲，搞得心疲，大体有以有以下几件事情：</p>\n<ul>\n<li>买房</li>\n<li>换工作</li>\n<li>适应新工作</li>\n<li>家里的一些伤心事</li>\n</ul>\n<h3 id=\"买房\"><a href=\"#买房\" class=\"headerlink\" title=\"买房\"></a>买房</h3><p>年初发现杭州房价不对劲，狠下心借钱买了房，现在想起也是蛮狠的，看了一周就买了。期间跟媳妇吵了不少，因为房子和钱，买的时候挺爽的，完了确实承受不小的压力，尤其是算钱的时候，我自己能够承受，让媳妇着实压力大了。因此才有后来换份工作，也是基于职业生涯以及大家都想着的钱考虑的。海康的工作强度其实挺大，也是适应了这个强度，因为是第一份工作，考虑得其实挺清楚的，也是很珍惜在海康的日子，心系海康，真有点一日为海康人，终生为海康人的意思。扯远了，还是说说房子的事情，为了媳妇才买的房子，现在房子涨价了，几乎翻了一番，算是当初狠心的回报，定居杭州的事情算是定下来，好好疼爱媳妇，好好生活。</p>\n<h3 id=\"换工作\"><a href=\"#换工作\" class=\"headerlink\" title=\"换工作\"></a>换工作</h3><p>一份工作做久了，其实挺不舍的，还有小伙伴们，也因为买房的事情，最后还是选择了离职。领导们也是再三挽留，确实让我很惊讶，这是对于我这两年工作的肯定。选择了转到前端这个方向，也就没有让自己回头了。前端对于我是个激动又紧张的职位，丢弃了多年的java经验，毅然决然地奔向frontEnd。</p>\n<p>选择光云有几点：1、光云重视前端，光云也算是个小公司；2、有小伙伴过来了；3、离住的地方比较近。</p>\n<h3 id=\"适应新工作\"><a href=\"#适应新工作\" class=\"headerlink\" title=\"适应新工作\"></a>适应新工作</h3><p>加入光云，挺开心，不过前期还是不适应的，IDE转到了mac，尝试了webstorm、sublime、vscode，其实还是适应eclipse。从Windows转到mac，不习惯了两周，最后走上了mac不归路。互联网公司，所有东西对于我都是新的，新的工作方式，新的编译工具，新的合作方式，新的学习方式，学会了markdown写博客，喜欢了mac的工作环境，认可光云的企业文化。工作每年的国外游很赞，这次没带媳妇去，很遗憾，美好的事情，是第一时间想跟媳妇分享的，不然就没有意义了。得列个旅游计划，定期带媳妇出去游玩。</p>\n<h3 id=\"家里的一些伤心事\"><a href=\"#家里的一些伤心事\" class=\"headerlink\" title=\"家里的一些伤心事\"></a>家里的一些伤心事</h3><p>今年也因为这个伤心事，工作动力不大，开心不起来，笑得时候也是故作，不过已经过去了，好好珍惜现在所有，去疼爱你所爱之人，千万不要说还有时间，时间真是不等人。</p>\n<h2 id=\"工作总结\"><a href=\"#工作总结\" class=\"headerlink\" title=\"工作总结\"></a>工作总结</h2><p>因为今年比较特殊，上半年在海康，下半年在光云，还是总结最近的半年吧。</p>\n<p>1、业务</p>\n<p>   主要做的是千牛的业务，基于小卖家的交易平台，其中我负责的是打单发货的模块，这块经过线上问题、重构、书写文档，理得已经很清晰了，但是在重构方面做得还不够充分。因为打单代码的复杂，其实就是因为太多人维护，只是迭代功能，并没有去做封装，去做重构而带来的复杂度，阅读性很差，缺乏注释。功能方面没有那么复杂，稍加梳理就能弄清，无外乎订单同步，发货单、快递单、电子面单的打印以及最后发货同步。</p>\n<p>自身的不足： 业务这块局限在打单发货方面，很少的涉及到移动端开发。</p>\n<p>2、技术</p>\n<p>进入光云，对于前端的技术栈已经得到不少补充，已经了解并学习的技术罗列下：</p>\n<ul>\n<li>工作环境： mac，vscode，有道云markdown笔记、hexo博客</li>\n<li>前端框架：mvp、react、react native、weex</li>\n<li>浏览器技术：websql、websocket、h5缓存技术，chrome调试技术</li>\n<li>后端： node技术，express框架，mongodb，redis</li>\n<li>打包技术：glup、webpack</li>\n<li>代码合作：git</li>\n</ul>\n<p>购买一台vps，开始自己搭建博客系统hexo，博客静态页面放在github上，然后vps写一个命令通过git拉取更新，搭建一个nginx映射到响应的index.html即可。</p>\n<p>自身的不足：学了不少东西，没有实践，比如react。</p>\n<p>3、团队合作</p>\n<p>一直以为我挺注重团队合作的，也是以团队合作为优先，经过下半年的工作，跟组内同事合作得不错，私交也不错。半年来，团建活动太少，增进感情的机会不多，通过只是写写代码，合作合作，是没有什么化学反应、火花的。每天的食堂聚餐帮助了不少，我是个慢热的人，处理关系也是慢慢的。</p>\n<p>自身的不足： 不够主动，不够主动、不够主动。</p>\n<p>不主动去要任务、不主动去承担、不主动去解决任务、不主动去关心同事</p>\n<h2 id=\"2017年要做几件事情\"><a href=\"#2017年要做几件事情\" class=\"headerlink\" title=\"2017年要做几件事情\"></a>2017年要做几件事情</h2><p>1、工作</p>\n<ul>\n<li>养成，坚持写博客</li>\n<li>学习更多技术，node的模块，实践react、weex</li>\n<li>重构负责的模块</li>\n<li>吃透业务，交易包括的所有业务，并且文档记录</li>\n<li>主动承担更多的事情，主动，主动，主动，及时出现并解决线上问题</li>\n<li>搞好同事关系</li>\n</ul>\n<p>2、生活</p>\n<ul>\n<li>去两个地方旅行</li>\n<li>办酒娶媳妇</li>\n<li>还房贷</li>\n<li>孝敬父母</li>\n</ul>\n","categories":[],"tags":["总结"]},{"title":"F12调试技巧","url":"http://yoursite.com/2016/12/29/F12调试技巧/","content":"<h1 id=\"1-常规\"><a href=\"#1-常规\" class=\"headerlink\" title=\"1.常规\"></a>1.常规</h1><h2 id=\"1-1-快捷键\"><a href=\"#1-1-快捷键\" class=\"headerlink\" title=\"1.1 快捷键\"></a>1.1 快捷键</h2><ul>\n<li>“F12”(windows)</li>\n<li>“Cmd”⌘ +“Option” +“I”（Mac）</li>\n<li>右键选择“Inspect Element 检查元素”</li>\n<li>Safari 需要在 首选项 &gt; 高级 &gt; 显示开发菜单，启用开发工具</li>\n<li>Firebug 是 Firefox 扩展</li>\n</ul>\n<h2 id=\"1-2-使用最新的开发版本浏览器\"><a href=\"#1-2-使用最新的开发版本浏览器\" class=\"headerlink\" title=\"1.2 使用最新的开发版本浏览器\"></a>1.2 使用最新的开发版本浏览器</h2><ol>\n<li><p>chrome Canary<br> <a href=\"https://www.google.com/intl/zh-CN/chrome/browser/canary.html\" target=\"_blank\" rel=\"external\">Chrome Canary</a> 是 Chrome 实验版，Canary 和 Chrome 可以同时安装。<br> 你可以通过 chrome://flags 进一步加强你的 Chrome 开发工具 ，启用“Enable Developer Tools experiments （启用开发工具实验）”。</p>\n<p> <img src=\"http://oixxlw0bj.bkt.clouddn.com/1479800206890.jpg\" alt=\"image\"></p>\n</li>\n<li><p>Firefox Aurora<br> <a href=\"http://www.mozilla.org/en-US/firefox/aurora/\" target=\"_blank\" rel=\"external\">Firefox Aurora</a> 提供 Firefox 最新特性预览。Aurora 不能和 Firefox 同时打开。</p>\n<p><img src=\"http://oixxlw0bj.bkt.clouddn.com/1479800391545.jpg\" alt=\"image\"></p>\n</li>\n<li><p>Webkit Nightly<br>  Webkit Nightly 可以和 Safari 同时运行。</p>\n<p> <img src=\"http://oixxlw0bj.bkt.clouddn.com/1479800523683.jpg\" alt=\"image\"></p>\n</li>\n<li><p>Opera Next 是 Opera 最新改良版，会提供一些新的功能和特性。</p>\n<p> <img src=\"http://oixxlw0bj.bkt.clouddn.com/1479800536638.jpg\" alt=\"image\"></p>\n</li>\n</ol>\n<h2 id=\"1-3-移动开发工具位置\"><a href=\"#1-3-移动开发工具位置\" class=\"headerlink\" title=\"1.3 移动开发工具位置\"></a>1.3 移动开发工具位置</h2><p> Chrome 开发工具，左下角图标允许改变停靠设置。快速点击它，会在底部和右侧切换。长按可以选择停靠选项（独立窗口打开），你也可以点击并拖拽移动开发工具。</p>\n<p>Firefox 和 Safari 开发工具，停靠选项在右上角临近关闭按钮的位置，可以新窗口打开。</p>\n<p>要改变停靠位置，可点击左上角小虫子，选择 Firebug 界面位置（上/下/左/右）。Firebug 右上角可以快速选择：最小化，新窗口，关闭。</p>\n<h1 id=\"2-console-控制台\"><a href=\"#2-console-控制台\" class=\"headerlink\" title=\"2 console 控制台\"></a>2 console 控制台</h1><h1 id=\"2-1-log-info-Debug-Warn-Error\"><a href=\"#2-1-log-info-Debug-Warn-Error\" class=\"headerlink\" title=\"2.1 log, info, Debug, Warn , Error\"></a>2.1 log, info, Debug, Warn , Error</h1><p>console.log()是每个前端用得最多的调试代码。<br>一般使用都是直接用，其实他还是可以这么用：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(<span class=\"string\">\"%s is %d years old.\"</span>, <span class=\"string\">\"Bob\"</span>, <span class=\"number\">42</span>)</div></pre></td></tr></table></figure>\n<p>是不是很熟悉，跟曾经学过的C语言打印日志一样一样的。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(\"%cThis is green text on a yellow background.\", \"color:green; background-color:yellow\");</div></pre></td></tr></table></figure>\n<p>上面代码是%c 模式，把第二个变量作为样式格式参数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log('Kings: ', kings);</div></pre></td></tr></table></figure>\n<p>可以输入多个值，用逗号隔开即可，方便在同一行输出对象和数组</p>\n<p>console.info() 输出提示信息；console.debug() 输出调试信息；console.warn() 输出警示信息；console.error() 输出错误信息</p>\n<h2 id=\"2-2-输入表格-console-table\"><a href=\"#2-2-输入表格-console-table\" class=\"headerlink\" title=\"2.2 输入表格 console.table\"></a>2.2 输入表格 console.table</h2><p>console.table() 可以用来输出数组或者对象列表，以一种合适的表格形式显示。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.table([[<span class=\"number\">10</span>, true, <span class=\"string\">\"blue\"</span>],[<span class=\"number\">5</span>, false]])</div></pre></td></tr></table></figure>\n<p> 输入如下的格式：</p>\n<p> <img src=\"http://oixxlw0bj.bkt.clouddn.com/1479801889947.jpg\" alt=\"image\"></p>\n<p>还可以自定义列名，属性名必须是对象中指定元素</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.table(&#123;</div><div class=\"line\">\t<span class=\"string\">\"London\"</span>:&#123;population:<span class=\"number\">8173194</span>, country:<span class=\"string\">\"UK\"</span>, elevation:<span class=\"string\">\"24m\"</span>&#125;,</div><div class=\"line\">\t<span class=\"string\">\"New York\"</span>:&#123;population:<span class=\"number\">8336697</span>, country:<span class=\"string\">\"USA\"</span>, elevation:<span class=\"string\">\"10m\"</span>&#125;&#125;,</div><div class=\"line\">\t[<span class=\"string\">\"population\"</span>, <span class=\"string\">\"country\"</span>])</div></pre></td></tr></table></figure>\n<p>第二个可选的变量允许你明确指定哪一列要输出</p>\n<p> <img src=\"http://oixxlw0bj.bkt.clouddn.com/1479802610952.jpg\" alt=\"image\"></p>\n<h2 id=\"2-3-console-Assert\"><a href=\"#2-3-console-Assert\" class=\"headerlink\" title=\"2.3 console.Assert()\"></a>2.3 console.Assert()</h2><p>  断言用于测试表达式真假</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.assert(!true, 'This is not true')；//输出”This is not true</div><div class=\"line\">console.assert(true, 'This is not true'); //什么也不输出</div></pre></td></tr></table></figure>\n<h2 id=\"2-4-持久控制台\"><a href=\"#2-4-持久控制台\" class=\"headerlink\" title=\"2.4 持久控制台\"></a>2.4 持久控制台</h2><p>有时页面加载时，你需要保留控制台信息。有时在点击或离开页面时，我们需要这个作为参考或者用来查看日志。</p>\n<p>在 Chrome 里，显示菜单里有“Preserve Log”，选择它将保存你的控制台内容。</p>\n<p><img src=\"http://oixxlw0bj.bkt.clouddn.com/1479803432279.jpg\" alt=\"image\"></p>\n<p>Firefox 默认会保存控制台信息。你可以点击右上角“清除”按钮清除控制台日志，或者打开/关闭工具。</p>\n<p>在 Firebug 里，有个显著的按钮用来保持控制台内容，就在控制台的上部。</p>\n<p>Opera 默认保存控制台内容，你可以右键选择“clear console”清除控制台日志或者重开工具。</p>\n<h2 id=\"2-5-任意tab打开console\"><a href=\"#2-5-任意tab打开console\" class=\"headerlink\" title=\"2.5 任意tab打开console\"></a>2.5 任意tab打开console</h2><p>在 Chrome ，尽管控制台有自己的 tab ，在任意 tab 按下“ESC”键即可打开控制台，因此不必切换 tab 了。</p>\n<p>Safari 控制台在开发工具的底部，“ESC”键用来切换控制台日志的可见性。在命令行执行一个命令也将打开控制台日志。</p>\n<p>在 Firefox ，快速切换到控制台：“Ctrl + Shift + K ”（Windows），“Cmd ⌘ + Option ⌥ + K ”（Mac）。    </p>\n<h2 id=\"2-6-引用当前和前一个元素\"><a href=\"#2-6-引用当前和前一个元素\" class=\"headerlink\" title=\"2.6 引用当前和前一个元素\"></a>2.6 引用当前和前一个元素</h2><p>如果你的“Elements”标签选择了一个元素，你可以用 $0 调用它。输入 $0.innerHTML 试试看。</p>\n<p>在 Firebug 和 Opera，你可以用 $1 选择前一个元素。</p>\n<p>在 Chrome 和 Safari，你可以通过 $1 - $4 选择更靠前的元素。</p>\n<p>在 Firebug ，你可以通过 $n(2) - $n(5) 选择更靠前的元素。</p>\n<h1 id=\"3-编辑\"><a href=\"#3-编辑\" class=\"headerlink\" title=\"3 编辑\"></a>3 编辑</h1><h2 id=\"3-1-搜索DOM节点\"><a href=\"#3-1-搜索DOM节点\" class=\"headerlink\" title=\"3.1 搜索DOM节点\"></a>3.1 搜索DOM节点</h2><p> 在 Chrome ，你可以按 Ctrl-F 打开对话框，CSS 选择器如期工作</p>\n<p><img src=\"http://oixxlw0bj.bkt.clouddn.com/1479803976290.jpg\" alt=\"image\"></p>\n<h2 id=\"3-2-修改CSS值\"><a href=\"#3-2-修改CSS值\" class=\"headerlink\" title=\"3.2 修改CSS值\"></a>3.2 修改CSS值</h2><p> 如果有个元素需要修改 margin，padding，width 或者 height，可以使用方向键增加/减少尺寸。简单使用上下方向键增加/减少1个单位。<br> “Shift” + 上下方向键，可以增加/减少10个单位；“Alt” + 上下方向键，可以增加/减少0.1个单位。<br> “Shift” + Page-Up / Page-Down，可以增加/减少100个单位。</p>\n<h2 id=\"3-3-改变-active，-hover，-focus，-visited-状态样式\"><a href=\"#3-3-改变-active，-hover，-focus，-visited-状态样式\" class=\"headerlink\" title=\"3.3 改变 :active， :hover， :focus， :visited 状态样式\"></a>3.3 改变 :active， :hover， :focus， :visited 状态样式</h2><p>在开发工具里修改 CSS 非常爽，但是碰到 hover 之类的伪类就有点挠头了。</p>\n<p>Chrome 有个按钮是干这用的，在“Elements”标签右手边看到一个虚线框和光标在一起的图标，它可以切换其它状态。</p>\n<p><img src=\"http://oixxlw0bj.bkt.clouddn.com/1479804330440.jpg\" alt=\"image\"></p>\n<h1 id=\"4-调试\"><a href=\"#4-调试\" class=\"headerlink\" title=\"4 调试\"></a>4 调试</h1><h2 id=\"4-1-用debugger\"><a href=\"#4-1-用debugger\" class=\"headerlink\" title=\"4.1 用debugger\"></a>4.1 用debugger</h2><p>添加此行代码：debugger; 可以自动创建断点，当开发工具打开时运行，断点会自动创建。</p>\n<p>尽管快速添加断点很方便，不用在开发工具一行一行找，小心不要把 debugger; 提交到线上环境。</p>\n<h2 id=\"4-2-条件断点\"><a href=\"#4-2-条件断点\" class=\"headerlink\" title=\"4.2 条件断点\"></a>4.2 条件断点</h2><p>不必每次生效时，条件断点很有用。例如，你知道你的代码在最后一项有 bug，你可以用条件判断在最后一项时激活 debugger。条件满足，断点触发。</p>\n<p>在 Chrome 中创建条件断点，先创建个正常的断点，然后右击断点选择“编辑断点”添加条件。</p>\n<p>在 Firebug ，先创建常规断点，然后右击出现输入框，可以添加条件。</p>\n<p>在 Firefox ，右击想创建断点的行，选择“增加条件断点”。</p>\n<p>在 IE，先创建常规断点，然后右击断点，选择“条件…”。</p>\n<p>在 Opera，先创建常规断点，然后右击断点，选择“添加条件”。</p>\n<p>在 Safari，确保脚本和“调试器”面板都打开，创建一个断点，然后在“调试器”面板右击同样的断点，选择“编辑断点”。</p>\n<h2 id=\"4-3-DOM断点\"><a href=\"#4-3-DOM断点\" class=\"headerlink\" title=\"4.3 DOM断点\"></a>4.3 DOM断点</h2><p>如果特定的 DOM 改变，你的页面会被破坏，或者你只想找出元素属性或子元素改变，哪些代码生效，Chrome 和 Firebug 均可以在 DOM 修改时设置断点，你可以找到代码问题的根源。简单点击你想监控的元素，右击选择“break on”选项。</p>\n<h2 id=\"4-4-XHR断点\"><a href=\"#4-4-XHR断点\" class=\"headerlink\" title=\"4.4 XHR断点\"></a>4.4 XHR断点</h2><p>在 Chrome ，可以为 XmlHttpRequest 设置断点，你可以调试 AJAX 请求。到“Sources”标签选择“XHR 断点”，点击右侧加号图标，输入部分或所有你想添加断点的 URL 。一旦请求返回，断点将生效，你可以看到返回的数据，并可单步调试后续操作。</p>\n<p>取消勾选可以关掉断点，右键选择“Delete Breakpoint 删除断点”删除断点。</p>\n<p>在 Firebug ，到网络标签选择“在 XHR 时中断”按钮，或者右键选择“在 XHR 时中断”，你也可以随意选择中断条件。</p>\n<h2 id=\"4-5调试压缩后的JavaScript\"><a href=\"#4-5调试压缩后的JavaScript\" class=\"headerlink\" title=\"4.5调试压缩后的JavaScript\"></a>4.5调试压缩后的JavaScript</h2><p>下断点让 JavaScript 调试更容易，但是如果代码已经放到生成环境，很可能已被压缩。如何调试最小化的代码呢？庆幸的是一些浏览器已经支持解压你的 JavaScript 。</p>\n<p>在 Chrome 和 Safari ，选择“脚本”标签，找到相应的文件，然后点击“{}”图标（pretty print，在面板底部）。</p>\n<p>在 IE ，点击工具图标选择下拉菜单，找到格式化 JavaScript 选项。</p>\n<p>Opera 自动格式化压缩的 JavaScript 。</p>\n<h2 id=\"4-6-使用-JavaScript-Source-Maps\"><a href=\"#4-6-使用-JavaScript-Source-Maps\" class=\"headerlink\" title=\"4.6 使用 JavaScript Source Maps\"></a>4.6 使用 JavaScript Source Maps</h2><p>当我们部署代码到生产环境时，比较明智的是压缩代码减少加载时间。压缩去除了无用的字符（比如注释），空行和空格。可是压缩后很难调试，无法单步调试，代码不易读。JavaScript source maps 调试压缩后 JavaScript 文件非常有用，它提供一个映射关联到未压缩文件。</p>\n<p>在 Chrome 开发工具，，“Settings 设置”菜单 -&gt; “General 常规”标签，激活“Enable Source Maps 启用 Source Maps ”。有兴趣的可以去google研究一番。</p>\n<h2 id=\"4-7-模拟User-Agent\"><a href=\"#4-7-模拟User-Agent\" class=\"headerlink\" title=\"4.7 模拟User Agent\"></a>4.7 模拟User Agent</h2><p>   安装 user-agent switcher 即可</p>\n<ul>\n<li><a href=\"https://chrome.google.com/webstore/category/extensions?hl=zh-CN\" target=\"_blank\" rel=\"external\">https://chrome.google.com/webstore/category/extensions?hl=zh-CN</a>  chrome打开这个网址</li>\n<li>打开商店网址，输入  user-agent switcher </li>\n</ul>\n<p><img src=\"http://oixxlw0bj.bkt.clouddn.com/1479808437884.jpg\" alt=\"image\"></p>\n<ul>\n<li>安装完成后，会在右上角显示一个插件ICO，直接点击使用</li>\n</ul>\n<p><img src=\"http://oixxlw0bj.bkt.clouddn.com/1479808512645.jpg\" alt=\"image\"></p>\n<h2 id=\"4-8-运行代码片段\"><a href=\"#4-8-运行代码片段\" class=\"headerlink\" title=\"4.8 运行代码片段\"></a>4.8 运行代码片段</h2><p>   在“Source”标签，“Sources”和“Content scripts”后面有个“Snippets ”标签，右键点击空区域，点“New”创建新的片段，写入一些代码，无论何时再想运行它时，右键点击选择“Run 运行”即可。</p>\n<p>  <img src=\"http://oixxlw0bj.bkt.clouddn.com/1479809359489.jpg\" alt=\"image\"></p>\n<h1 id=\"5-移动端\"><a href=\"#5-移动端\" class=\"headerlink\" title=\"5 移动端\"></a>5 移动端</h1><h2 id=\"5-1-开发工具IOS\"><a href=\"#5-1-开发工具IOS\" class=\"headerlink\" title=\"5.1 开发工具IOS\"></a>5.1 开发工具IOS</h2><p>把 IOS 设备连接到可用的 Mac，打开 Mac 和 IOS 设备的 Safari 。</p>\n<p>找到 Safari 的“Develop 开发”菜单，第一个菜单分隔线的后面应该是你要连接的 IOS 设备的名字。在子菜单选择你想调试的页面。</p>\n<p>Safari 的开发工具将以弹出窗口的式出现，你可以调试移动设备的站点了。</p>\n<h2 id=\"5-2-开发工具Android\"><a href=\"#5-2-开发工具Android\" class=\"headerlink\" title=\"5.2 开发工具Android\"></a>5.2 开发工具Android</h2><p>用USB线连接手机和电脑，然后在chrome浏览器中去找到手机。<br>在电脑上的chrome浏览器中，导航到chrome://inspect，确认 Discover USB devices 是选中状态，并且可以看到已经发现我的安卓手机</p>\n","categories":["html5"],"tags":["F12"]},{"title":"html5 websocket梳理","url":"http://yoursite.com/2016/10/11/html5 websocket梳理/","content":"<hr>\n<p>websocket是HTML5新特性中最值得说说的改进。介绍之前先介绍几种HTTP的通信方式</p>\n<h2 id=\"1-HTTP通信方式\"><a href=\"#1-HTTP通信方式\" class=\"headerlink\" title=\"1 HTTP通信方式\"></a>1 HTTP通信方式</h2><blockquote>\n<p>http是用于文档传输简单同步请求的响应式协议，它是无状态的，半双工</p>\n</blockquote>\n<h3 id=\"1-1-轮训polling\"><a href=\"#1-1-轮训polling\" class=\"headerlink\" title=\"1.1 轮训polling\"></a>1.1 轮训polling</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// client</div><div class=\"line\">var time = 1000 * x;  // 轮询频率 / ms</div><div class=\"line\">setInterval(function()&#123;</div><div class=\"line\">    //ajax </div><div class=\"line\">&#125;, time);</div></pre></td></tr></table></figure>\n<p>用定时的方式实现，当时间过短，服务器负担大，产生大量不必要连接消耗，时间过长，信息通知不及时。</p>\n<h3 id=\"1-2-长轮训long-polling\"><a href=\"#1-2-长轮训long-polling\" class=\"headerlink\" title=\"1.2 长轮训long polling\"></a>1.2 长轮训long polling</h3><p>客户端向服务器请求，这个请求在有数据时返回，如果没有数据，请求会一直被挂起，知道有数据或者超时。结束了再次请求。HTTP/1.1之后，浏览器默认连接为长连接( keep-alive )。</p>\n<p><img src=\"http://note.youdao.com/yws/api/personal/file/WEB1d7603f7dabd184ce67d9f8e74e44039?method=download&amp;shareKey=9d667c0c3b8617cf3eb3e99e55bb2709\" alt=\"image\"></p>\n<p>无需第三方插件仅仅依靠长连接维持客户端与服务器交互的技术成为comet或反向Ajax。</p>\n<blockquote>\n<p>对于IE浏览器，同时建立两个长连接之后，第三个HTTP请求会被阻塞。HTTP/1.1规范对长连接有相应规定，不建议建立两个以上长连接。</p>\n</blockquote>\n<h3 id=\"1-3-流化streaming\"><a href=\"#1-3-流化streaming\" class=\"headerlink\" title=\"1.3 流化streaming\"></a>1.3 流化streaming</h3><p>客户端发送一个请求，服务器发送并维护一个持续更新和保持打开的开放响应，除非这个请求超时或者主动关闭，否则服务端会一直把数据推给客户端。</p>\n<p>流化有两种方案：</p>\n<ul>\n<li>第一种是iframe标签，通过在HTML页面添加一个隐藏iframe，把iframe的src属性设置成一个长连接请求，服务器就会一直推数据过来。返回的数据形式就是js的函数调用。</li>\n<li>第二种利用multi-part标志，只有部分浏览器有，因此有局限性。这个字段这里暂时不描述。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** 使用 Forever IFrame */</div><div class=\"line\">// client</div><div class=\"line\">&lt;iframe id=&apos;hidden_iframe_polling&apos; name=&apos;hidden_iframe_polling&apos; style=&apos;display:none;&apos; /&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">var url=&apos;&apos;;             // 请求地址</div><div class=\"line\">var time = 1000 * x;    // 轮询频率 / ms</div><div class=\"line\">setInterval(function()&#123;</div><div class=\"line\">    document.getElementById(&apos;hidden_iframe_polling&apos;).src = url + &quot;?t=&quot; + new Date();    //时间戳保证每次都是最新请求</div><div class=\"line\">    window.frames[&quot;hidden_iframe_polling&quot;].location.reload();</div><div class=\"line\">&#125;, time);</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** 使用 multi-part */</div><div class=\"line\">// client</div><div class=\"line\">var url = &apos;&apos;;                // 请求地址</div><div class=\"line\">var type = &apos;&apos;;               // 请求方式 post / get</div><div class=\"line\">var xhr = new XMLHttpRequest();</div><div class=\"line\">xhr.multipart = true;        // multi-part 标志设置为 true</div><div class=\"line\">xhr.timeout = 1000 * x;      // 超时 / ms</div><div class=\"line\">xhr.onreadystatechange = state_change_call;</div><div class=\"line\">xhr.open(type, url, true); </div><div class=\"line\">xhr.send(null);</div><div class=\"line\">function state_change_call()&#123;</div><div class=\"line\">    //回调</div><div class=\"line\">&#125;</div><div class=\"line\">// server</div><div class=\"line\">// 建立长连接，设置content-type的值为multipart/mixed或multipart/x-mixed-replace</div><div class=\"line\">//  例:multipart/x-mixed-replace;boundary=&quot;string类型数据&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"1-4-其他\"><a href=\"#1-4-其他\" class=\"headerlink\" title=\"1.4 其他\"></a>1.4 其他</h3><p>其它还有捎带轮训（pingybakc polling）、第三方插件（flashSocket）等。</p>\n<p>websocket应用已经很成熟，但是考虑到一些老浏览器不支持此特性，未了兼容性，也有用以上的一些方案。成熟的WebSocket组件，大多也会提供降级方案，采用comet技术等。</p>\n<h2 id=\"2-WebSocket\"><a href=\"#2-WebSocket\" class=\"headerlink\" title=\"2 WebSocket\"></a>2 WebSocket</h2><blockquote>\n<p>WebSocket是全双工、双向、单套接字连接。</p>\n</blockquote>\n<p>说得形象点，我们可以认为WebSocket是Http连接的升级版本。</p>\n<h3 id=\"2-1-WebSocket-Protocol\"><a href=\"#2-1-WebSocket-Protocol\" class=\"headerlink\" title=\"2.1 WebSocket Protocol\"></a>2.1 WebSocket Protocol</h3><p>一旦建立起连接，客户端不需要再次发起，也能及时接收到服务器端数据，websocket相比Http通信更加简洁、高效、直观，它解决了HTTP通信的许多不足，能够互补HTTP的欠缺的特性，这就是吸引我们去使用的理由。</p>\n<p>判断支持原生WebSocket：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(window.WebSocket)&#123; </div><div class=\"line\">   // 支持WebSocket  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>WebSocket连接其实也是基于HTTP请求，那如何区分这两者呢？<br>很简单，只要在请求头里加入一个Upgrade的请求头，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">//</div><div class=\"line\">// -client </div><div class=\"line\">// 浏览器发送一个请求到服务器，表示它想把HTTP协议转为WebSocket。客户端通过更新头字段（Upgrade header）实现了这个目的</div><div class=\"line\">GET /echo HTTP/1.1</div><div class=\"line\">Sec-WebSocket-Key: xx</div><div class=\"line\">Sec-WebSocket-Verson: xx </div><div class=\"line\">Connection: Upgrade</div><div class=\"line\">Upgrade: websocket</div><div class=\"line\">//</div><div class=\"line\">// -server </div><div class=\"line\">// 如果服务器识别WebSocket协议，它通过Upgrade header接受协议转换</div><div class=\"line\">Connection:Upgrade</div><div class=\"line\">Sec-WebSocket-Accept: xx</div><div class=\"line\">Upgrade: WebSocket</div></pre></td></tr></table></figure>\n<p>此时HTTP连接会被基于TCP/IP连接的WebSocket连接所取代。WebSocket连接默认使用和HTTP(80)或者HTTPS(443)一样的端口，当然，你可以用其它端口。<br>WebSocket为了完成握手，服务器必须响应一个键值，服务器通过这个键值才能知道是WebSocket连接协议。那么这个键值如何计算的呢？响应函数从请求头的Sec-WebSocket-Key取值，然后根据这个值通过SHA1计算出键值并返回其base64字段串。建立WebSocket连接握手成功后，服务端就会一直以frame形式往客户端响应数据。帧格式此处不再敖述。</p>\n<h2 id=\"2-2-API\"><a href=\"#2-2-API\" class=\"headerlink\" title=\"2.2 API\"></a>2.2 API</h2><h3 id=\"2-2-1-WebSocket构造\"><a href=\"#2-2-1-WebSocket构造\" class=\"headerlink\" title=\"2.2.1  WebSocket构造\"></a>2.2.1  WebSocket构造</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var url =&quot;&quot;;                    //URL地址</div><div class=\"line\">var protocols = [];              //协议数组</div><div class=\"line\">var ws = new WebSocket(url, protocols);    //构造函数</div></pre></td></tr></table></figure>\n<p>WebSocket(url, protocols)构造函数接受一个或两个参数。</p>\n<p>第一个参数url指定要连接的url。这个url可能是ws:或wss:，类似于HTTP请求的http:或者https:。WebSocket也提供了传输层安全性的连接( TLS/SSL)。</p>\n<p>第二个是一个协议数组，非必填项。如果它是一个字符串,它相当于一个数组组成的字符串，如果省略,它相当于空数组。其实在protocols参数指定的协议基本有三种类型：一、注册协议，向注册管理实体IANA正式注册的标准协议；二、开放协议，广泛使用的标准化协议，如XMPP或STOMP；三、自定义协议，自己编写并和WebSocket一起使用的协议。例如，protocols有可能是简单对象访问协议( SOAP )或其它自定义协议。</p>\n<p>当创建的WebSocket构造函数被调用时，会先解析URL参数，获取主机、端口、资源名称、安全。如果操作失败，抛出SyntaxError异常并终止操作。如果存在一个安全组件，例如套接字安全协议https,但分析出这个安全是false，例如无效的安全证书，那么抛出一个SecurityError异常。如果protocols协议数组或字符串中Sec-WebSocket-Protocol头字段定义的值超过一次不匹配，则抛出一个SyntaxError异常并中止。此时返回这个WebSocket的对象，但是后台依然会继续这些操作。\n　　</p>\n<h3 id=\"2-2-2-事件\"><a href=\"#2-2-2-事件\" class=\"headerlink\" title=\"2.2.2 事件\"></a>2.2.2 事件</h3><p>WebSocket对象存在4个事件，包括open、message、error、close。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var socket = new WebSocket(&apos;ws://game.example.com:12010/updates&apos;);</div><div class=\"line\">// 打开事件</div><div class=\"line\">socket.onopen = function (e) &#123;</div><div class=\"line\">    console.log(&quot;websocket 打开&quot;);</div><div class=\"line\">&#125;;</div><div class=\"line\">// 消息事件</div><div class=\"line\">socket.binaryType = &quot;&quot;;</div><div class=\"line\">socket.onmessage = function (e) &#123;</div><div class=\"line\">    if (typeof e.data === &quot;string&quot;)&#123;</div><div class=\"line\">        console.log(&quot;处理文本格式数据.&quot;) ;</div><div class=\"line\">        if (event.data == &apos;on&apos;) &#123;</div><div class=\"line\">            console.log(&quot;处理当数据等于on时.&quot;) ;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">//error 事件</div><div class=\"line\">socket.onerror = function(e)&#123;</div><div class=\"line\">    console.log(&quot;正在处理错误&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">//关闭事件</div><div class=\"line\">socket.onclose = function(e)&#123;</div><div class=\"line\">    console.log(&quot;连接关闭&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另外，close事件有三个属性，可用于处理和恢复：wasClean、code、reason。wasClean属性为布尔类型，表示是否顺利连接，如果接收到一个正常的close帧，则该属性为true，如果因为其它原因关闭，该属性为false。code和reason分别代表错误代码和关闭原因。</p>\n<h3 id=\"2-2-3-方法\"><a href=\"#2-2-3-方法\" class=\"headerlink\" title=\"2.2.3 方法\"></a>2.2.3 方法</h3><p>WebSocket有两个方法：send()和close()。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 发送消息</div><div class=\"line\">var msg =&quot;&quot;;           //定义消息</div><div class=\"line\">socket.onopen = function(e)&#123;</div><div class=\"line\">    socket.send(msg);      //发送</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//或者</div><div class=\"line\">function sendHandler(e)&#123;</div><div class=\"line\">    if (ws.readState === WebSocket.Open)&#123;</div><div class=\"line\">        socket.send(msg);</div><div class=\"line\">    &#125; else &#123; &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 关闭方法</div><div class=\"line\">var code = &quot;&quot;;    //定义代码</div><div class=\"line\">var reason = &quot;&quot;;  //关闭原因</div><div class=\"line\">socket.close(code,reason);</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-4-状态\"><a href=\"#2-2-4-状态\" class=\"headerlink\" title=\"2.2.4 状态\"></a>2.2.4 状态</h3><p>readState，用于报告连接状态。</p>\n<table>\n<thead>\n<tr>\n<th>常量</th>\n<th>值</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WebSocket.CONNECTION</td>\n<td>0</td>\n<td>正在握手请求中，还未完成连接</td>\n</tr>\n<tr>\n<td>WebSocket.OPEN</td>\n<td>1</td>\n<td>连接已打开</td>\n</tr>\n<tr>\n<td>WebSocket.CLOSING</td>\n<td>2</td>\n<td>连接正在关闭</td>\n</tr>\n<tr>\n<td>WebSocket.CLOSED</td>\n<td>3</td>\n<td>连接已关闭</td>\n</tr>\n</tbody>\n</table>\n<p>从上表可以知道WebSocket的生命周期。</p>\n<p>还有一个bufferAmount，这个用于检查发往服务器的缓冲数量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// -client</div><div class=\"line\">var info_size= 1024 * 100;    //传输数据长度</div><div class=\"line\">var _url =&quot;&quot;;            //WebSocket服务器地址</div><div class=\"line\">var ws = new WebSocket(_url);</div><div class=\"line\">ws.onopen = function()&#123;</div><div class=\"line\">    setInterval(function()&#123;</div><div class=\"line\">        if(ws.bufferedAmount &lt; info_size)&#123;</div><div class=\"line\">            //do something</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,1000);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-其他\"><a href=\"#3-其他\" class=\"headerlink\" title=\"3 其他\"></a>3 其他</h2><p>SSE ( Server-Send Event )，这个不属于WebSocket，他也属于HTML的新特性，它加强了comet技术。SSE主要功能是向客户端广播或推送消息，如果仅需求服务器单向推送，SSE就很适合，经常被用于推送新闻、天气。</p>\n","categories":["html5"],"tags":["html5","http"]},{"title":"git 使用心得","url":"http://yoursite.com/2016/08/03/git使用心得/","content":"<h3 id=\"1-安装Git\"><a href=\"#1-安装Git\" class=\"headerlink\" title=\"1.安装Git\"></a>1.安装Git</h3><p>Git之前是在linux上开发的，所以很长一段时间只能在linux上跑，现在也有了Windows版本的Git。</p>\n<p><strong>在Linux上安装Git</strong><br>首先，你可以试着输入git，看看系统有没有安装Git：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git</div><div class=\"line\">The program <span class=\"string\">'git'</span> is currently not installed. You can install it by typing:</div><div class=\"line\">sudo apt-get install git</div></pre></td></tr></table></figure></p>\n<p>上面代码即是没有安装以及如何安装的意思。<br>Ubuntu linux或者debain，命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get install git</div></pre></td></tr></table></figure>\n<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。<br><strong>在Mac OS X上安装Git</strong></p>\n<p>Mac os X上有两种方式，如下：</p>\n<ol>\n<li>homebrew，安装homebrew，然后通过homebrew一键搞定，具体参考文档：<a href=\"http://brew.sh/\" target=\"_blank\" rel=\"external\">http://brew.sh/</a></li>\n<li>第二种简单，直接从AppStore安装Xcode，Xcode集成了GIt，不过默认没装，你需要运行Xcode，菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。xcode是免费的，功能相当强大。</li>\n</ol>\n<p><strong>在Mac OS X上安装Git</strong><br>本人不喜欢用Windows开发，如果不是情势所逼，不推荐windows作为开发环境。windows下安装的话，直接到官网下载 <a href=\"https://git-for-windows.github.io\" target=\"_blank\" rel=\"external\">https://git-for-windows.github.io</a> 下载，然后默认安装即可。安装完成后，使用Git-&gt;Git Bash，跳出一个命令行窗口，说明安装成功。</p>\n<p>安装完成，还需要配置，在命令行输入：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"Your Name\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"email@example.com\"</span></div></pre></td></tr></table></figure></p>\n<p>注意git config命令的–global参数，使用这个菜蔬，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>\n<p>未完待续</p>\n","categories":["工具"],"tags":["git"]},{"title":"http请求缓存机制","url":"http://yoursite.com/2016/08/01/http请求缓存机制/","content":"<hr>\n<blockquote>\n<p>摘要：在前端开发过程中，我们可能会经常遇到浏览器缓存的问题。本文详细介绍浏览器缓存机制，帮助读者更深层次的理解浏览器缓存。</p>\n</blockquote>\n<p>缓存是着存储指定资源的一份拷贝，并在下次请求该资源时提供该拷贝的技术。缓存大致可归为两类：私有与共享缓存。</p>\n<ul>\n<li>共享缓存存储的数据可以被多用户使用，例如架设web代理</li>\n<li>私有缓存只能用于单独用户，就是本地数据</li>\n</ul>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><ul>\n<li>no-cache：浏览器和缓存服务器都不应该缓存页面信息；</li>\n<li>public：浏览器和缓存服务器都可以缓存页面信息；</li>\n<li>no-store：请求和响应的信息都不应该被存储在对方的磁盘系统中；</li>\n<li>must-revalidate：对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时</li>\n<li>Last-Modified： 只页面的最后生成时间，GMT格式</li>\n<li>Expires： 过时期限值，GMT格式，指浏览器或缓存服务器在该时间点后必须从真正的服务器中获取新的页面信息</li>\n</ul>\n<h3 id=\"缓存目标\"><a href=\"#缓存目标\" class=\"headerlink\" title=\"缓存目标\"></a>缓存目标</h3><p>常见的HTTP缓存只能存储GET响应，对于其他类型的响应无能为力。<br>缓存的形式：</p>\n<ul>\n<li>成功响应： 200（ok），GET请求成功状态，包括html、imges、files</li>\n<li>永久重定向： 301响应（永久移动，Moved Permanently）</li>\n<li>错误响应： 404响应（not found）</li>\n<li>不完整的响应： 206响应（Partial Content）</li>\n<li>除了响应的其他适合缓存的内容</li>\n</ul>\n<h2 id=\"控制缓存\"><a href=\"#控制缓存\" class=\"headerlink\" title=\"控制缓存\"></a>控制缓存</h2><h3 id=\"cache-control控制头\"><a href=\"#cache-control控制头\" class=\"headerlink\" title=\"cache-control控制头\"></a>cache-control控制头</h3><p> HTTP/1.1中的应用头，使用不同指令定义缓存策略</p>\n<h4 id=\"请求信息完全不存\"><a href=\"#请求信息完全不存\" class=\"headerlink\" title=\"请求信息完全不存\"></a>请求信息完全不存</h4><p>浏览器不存储服务器返回的内容，每次请求都走服务器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cache-Control: no-store</div><div class=\"line\">Cache-Control: no-cache, no-store, must-revalidate</div></pre></td></tr></table></figure>\n<h4 id=\"不缓存\"><a href=\"#不缓存\" class=\"headerlink\" title=\"不缓存\"></a>不缓存</h4><p>缓存会向原始服务器发送请求验证，在发布缓存备份之前</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cache-Control: no-cache</div></pre></td></tr></table></figure>\n<h4 id=\"私有公有缓存\"><a href=\"#私有公有缓存\" class=\"headerlink\" title=\"私有公有缓存\"></a>私有公有缓存</h4><p>公有指令显示所有响应都有缓存，这个很有用，如果那些有http验证或者响应状态不能正常缓存，现在都能够缓存了。相反，私有指令表示只针对单独用户的响应不能共享缓存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cache-Control: private</div><div class=\"line\">Cache-Control: public</div></pre></td></tr></table></figure>\n<h4 id=\"Expiration\"><a href=\"#Expiration\" class=\"headerlink\" title=\"Expiration\"></a>Expiration</h4><p>这里最重要的指令是“max-age=<seconds>”，它表示缓存的最长生命周期。相对于Expires，这个指令是相对于请求的时间。对于应用中的静态文件可以增加强制缓存，包括图片、css文件和js文件。</seconds></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Cache-Control: max-age=31536000</div></pre></td></tr></table></figure>\n<h3 id=\"Pragma头\"><a href=\"#Pragma头\" class=\"headerlink\" title=\"Pragma头\"></a>Pragma头</h3><p>Pragma是HTTP/1.0的应用头，它没有指定http响应，因此在HTTP/1.1中没有一个可用的以及可替换Cache-Control头，尽管他跟Cache-Control: no-cache功能相似。一般使用Pragma头来兼容HTTP/1.0客户端。</p>\n<h2 id=\"缓存更新机制\"><a href=\"#缓存更新机制\" class=\"headerlink\" title=\"缓存更新机制\"></a>缓存更新机制</h2><p>一旦资源被缓存，他理论上是可以一直缓存。缓存存储空间有限，所以有些资源需要从存储中移除，这个叫做缓存回收。另外，一些资源可能变更，所以资源也需要更新。因为HTTP是cs协议，一旦资源变更服务端无法接触缓存和客户端，所以需要传递资源的过期时间。回收算法给予未过期资源权限高于过期资源。当缓存接收到过期资源，他会转发具有 If-None-Match头的请求，如果这个资源已经不再是有效资源。如果这样，服务端会返回304头（Not Modified），不再发送资源，进而节省了带宽。</p>\n<p><img src=\"https://mdn.mozillademos.org/files/13771/HTTPStaleness.png\" alt=\"image\"></p>\n<h3 id=\"加速资源\"><a href=\"#加速资源\" class=\"headerlink\" title=\"加速资源\"></a>加速资源</h3><p>以某种方式不频繁更新文件名称：在url，通常是在文件名里，增加版本信息。</p>\n<p> <img src=\"https://mdn.mozillademos.org/files/13779/HTTPRevved.png\" alt=\"image\"></p>\n<h2 id=\"cache验证\"><a href=\"#cache验证\" class=\"headerlink\" title=\"cache验证\"></a>cache验证</h2><p>当用户按下重新加载的按钮就触发cache的重新生效。如果http头包括Cache-control: must-revalidate，正常浏览网页也可以触发重新生效。也可以在浏览器配置中设置强制缓存是否生效。</p>\n<h3 id=\"Etag\"><a href=\"#Etag\" class=\"headerlink\" title=\"Etag\"></a>Etag</h3><p>HTTP协议规格说明定义ETag为“被请求变量的实体值”，另一种说法是，ETag是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。</p>\n<p>实例讲解：<br>想必有不少用户经常订阅大虾们的RSS，大虾们更新博客的速度应该是没有那么快，一天一更已经是高产，所以就有可能好几天都没有更新，这时候如果每次刷新RSS订阅的时候都去服务端重新获取内容，如果体量一大，服务端压力就会很大，此时就可以用Etag来做。</p>\n<ol>\n<li><p>每次用户订阅的时候，首次订阅服务端返回200，并发回网页内容，在http响应头中有etag消息头，此时我们不需要关心这个值到底什么意思，记录下来。</p>\n</li>\n<li><p>然后我们再次刷新页面，把获取到的etag值放到请求头的If-None-Match字段里。</p>\n</li>\n<li>服务器拿到这个请求的话，首先去判断请求头的If-None-Match字段是否与服务端的Etag值相等，如果服务端则认为客户端有最新的缓存，则发回一个304（Not modified）响应。如果比较值不相同，则把最新的RSS内容返回给客户端，相应的Etag值也变更了。</li>\n</ol>\n","categories":["http"],"tags":["http","缓存"]},{"title":"使用Ubuntu 新建vpn过程","url":"http://yoursite.com/2016/07/31/使用Ubuntu新建vpn过程/","content":"<p>1、更新软件源<br>     sudo apt-get update</p>\n<p>2、安装pip<br>   sudo apt-get install python-pip</p>\n<p>3、安装shadowsocks<br>   sudo pip install shadowsocks</p>\n<p>4、运行shadowsocks<br>   sudo ssserver -p 8388 -k  password -m aes-256-cfb -d start</p>\n<p>  #ssserver -p 服务器端口 -k 密码 -m 加密方法 -m  加密协议  -d 后台运行</p>\n<p>5、停止运行<br>     sudo ssserver  -d  stop</p>\n<p>   #查询日志<br>   sudo less/more /var/log/shadowsocks.log<br>   sudo tail -f  /var/log/shadowsocks.log</p>\n<p>6、下载shadowsocks地址：<br>       <a href=\"http://www.ishadowsocks.org/\" target=\"_blank\" rel=\"external\">http://www.ishadowsocks.org/</a></p>\n<p>7、digitalocean官网：<br>     <a href=\"https://m.do.co/c/c038014ec8a1\" target=\"_blank\" rel=\"external\">https://m.do.co/c/c038014ec8a1</a>   通过此链接可以免费领取10美元费用，相当于免费使用2个月的vps，亲测可用</p>\n","categories":["工具"],"tags":["vpn"]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"<p>link:</p>\n<ul>\n<li>name: 三省吾身丶丶<br>info: 芝兰生于深林，不以无人而不芳<br>url: <a href=\"http://blog.guowenfh.com/\" target=\"_blank\" rel=\"external\">http://blog.guowenfh.com/</a><br>avatar: <a href=\"http://blog.guowenfh.com/images/guowenfh.jpg\" target=\"_blank\" rel=\"external\">http://blog.guowenfh.com/images/guowenfh.jpg</a></li>\n</ul>\n","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]